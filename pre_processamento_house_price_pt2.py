# -*- coding: utf-8 -*-
"""pre_processamento_house_price_pt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OAsFm2ivOPT4Uyt_c8yV9W2exlTCe2pd

Neste desafio vamos passar por todo o processo de pré-processamento e criação de um modelo de aprendizado de máquina no famoso conjunto de dados “House Price”, que é usado em competições de Machine Learning. Neste dataset você pode encontrar mais 70 atributos sobre casas e seus respectivos preços.

**Objetivo:** É seu trabalho como engenheiro da computação prever o preço de venda de cada casa, ou seja, criar um modelo para isso.

**Itens que você deve cumprir**:

***PARTE 2 ***

*   Utilizar a correlação de person e spearman para detectar as 5 variáveis com maior correlação. 
*   Plotar a matriz de correlação de ambos 
*   Agora com os 5 atributos mais importantes aplicar ao modelo de regressão (dado pelo professor) e verificar a acurácia
*   Utilizar a RFE para detectar as 5 variáveis importantes. 
*   Agora com os 5 atributos mais importantes aplicar ao modelo de regressão (dado pelo professor) e verificar a acurácia
*   Utilizar o seaborn para plotar 2 variáveis 'lineares'
*   Utilizar PCA selecionando 2 atributos e transformar em 1 componente 
*   Aplicar o dataset (agora com PCA) ao modelo de regressão (dado pelo professor) e verificar a acurácia

**Importando as principais bibliotecas**
"""

import pandas as pd #biblioteca utilizada para o tratamento de dados via dataframes 
import numpy as np #biblioteca utilizada para o tratamento de valores numéricos (vetores e matrizes)
import matplotlib.pyplot as plt #biblioteca utilizada para construir os gráficos
import seaborn as sns #biblioteca utilizada para construir os gráficos
from sklearn.linear_model import LogisticRegression # biblioteca para regressão logística 
from sklearn.decomposition import PCA #biblioteca para PCA
from sklearn.feature_selection import RFE #biblioteca para aplicação RFE
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LinearRegression #importa o modelo de regressão linear univariada
from sklearn.metrics import r2_score #método para o cálculo do R2 (coeficiente de determinação)

"""**Obtendos os dados utilizano google files**"""

from google.colab import files  #biblioteca utilizada para carregar os dados para o google colab
uploaded = files.upload()

"""**Ler o arquivo CSV para um data frame** -> utilizar o read_csv"""

nome_do_arquivo="Dataset_H.csv" 
dataframe = pd.read_csv(nome_do_arquivo) #carrega o CSV para um dataframe

"""***Apresentar uma "exemplo" do dataframe (5 instâncias) ***-> Utulizar head()"""

dataframe.head()

"""***Apresentar as informações sobre as instâncais do dataset, como : N-Entradas, N-Atributos e Tipos ***-> Utilizar o comando info()"""

dataframe.info()

"""**Verificar o somatório de dados Nullos em cada atributo** -> utilizar os camandos isnull e sum"""

dataframe.isnull().sum()

"""**Calcular média para substituir nos valores nulos** ->  Utilizar o comando mean"""

dataframe['LotFrontage'].fillna(dataframe['LotFrontage'].mean(),inplace = True)

"""***Preencher os dados nulos com a média ***-> utilizar o comando fillna

**Verificar o somatório de dados nulos em cada atributo** -> utilizar os camandos isnull e sum
"""

dataframe.isnull().sum()

"""***Verificar possíveis outliers -> ***utilizar o boxplot """

sns.set(style="whitegrid")
ax = sns.boxplot(y="SalePrice",
                 data=dataframe)

"""***Analisar as variáveis e definir um método para trasnformar o dado categórico ***-> comando dummies para One Hot Encoding ou labelencoder para OrdinalEncoder"""

labelencoder = LabelEncoder()
dataframe['LotConfig_encoded'] = labelencoder.fit_transform(dataframe['LotConfig'])

one_hot_Street = pd.get_dummies(dataframe['Street'])
dataframe =  dataframe.join(one_hot_Street)

"""***Escolher 10 variáveis de entrada e a variável preço como saíada***


dica:

df_final = dataframe[['SalePrice','LotFrontage','OverallQual','TotalBsmtSF', '1stFlrSF','2ndFlrSF','GarageCars','GarageArea','YearBuilt','Grvl','Pave','LotConfig_encoded']] 


"""

df_final = dataframe[['SalePrice','LotFrontage','OverallQual','TotalBsmtSF', '1stFlrSF','2ndFlrSF','GarageCars','GarageArea','YearBuilt','Grvl','Pave','LotConfig_encoded']]

x = df_final.drop('SalePrice',axis=1)

y = df_final['SalePrice']

"""**Aplicar ao modelo de regressão (dado pelo professor) e verificar a acurácia**"""

#Realiza a construção do modelo de regressão
reg= LinearRegression()
#x_Reshaped=x.reshape((-1, 1)) #coloca os dados no formato 2D
regressao= reg.fit(x,y) # encontra os coeficientes (realiza a regressão)

#realiza a previsão
previsao=reg.predict(x)

#parâmetros encontrados
print('Y = {}X {}'.format(reg.coef_,reg.intercept_))

R_2 = r2_score(y, previsao)  #realiza o cálculo do R2

print("Coeficiente de Determinação (R2):", R_2)

plt.figure(figsize=(10, 10), dpi=100)
plt.scatter(x.index[1:200], y[1:200],  color='gray') #realiza o plot do gráfico de dispersão
plt.scatter(x.index[1:200], previsao[1:200],  color='blue') #realiza o plot do gráfico de dispersão
plt.show()

"""**------------------- Início PARTE 2 ---------------**

**Verificar por meio da correlação de Pearson as variáveis mais importantes**
"""

corr_pearson = x.apply(lambda x : x.corr(y, method='pearson'))

ind_pearson = np.argsort(corr_pearson)

print(corr_pearson[ind_pearson])

"""**Verificar por meio da correlação de Spearman as variáveis mais importantes**"""

corr_spearman = x.apply(lambda x : x.corr(y, method='spearman'))

ind_spearman = np.argsort(corr_spearman)

print(corr_spearman[ind_spearman])

"""**Plotar Gráficos da Correlação**"""

mt_corr_pearson = dataframe.corr(method='pearson')

mt_corr_pearson.style.background_gradient(cmap='coolwarm').set_precision(2)

mt_corr_spearman = dataframe.corr(method='spearman')

mt_corr_spearman.style.background_gradient(cmap='coolwarm').set_precision(2)

"""**Aplicar ao modelo de regressão (dado pelo professor) e verificar a acurácia**"""

#Realiza a construção do modelo de regressão
reg= LinearRegression()
#x_Reshaped=x.reshape((-1, 1)) #coloca os dados no formato 2D
regressao= reg.fit(x,y) # encontra os coeficientes (realiza a regressão)

#realiza a previsão
previsao = reg.predict(x)

R_2 = r2_score(y, previsao)  #realiza o cálculo do R2

print("Coeficiente de Determinação (R2):", R_2)

"""**Verificar por meio do algoritmo RFE as variáveis mais importantes**"""

model_RFE = LinearRegression()

rfe = RFE(model_RFE,2)

fit = rfe.fit(x,y)

"""**Aplicar ao modelo de regressão (dado pelo professor) e verificar a acurácia**"""

#Realiza a construção do modelo de regressão
reg= LinearRegression()
#x_Reshaped=x.reshape((-1, 1)) #coloca os dados no formato 2D
regressao= reg.fit(x,y) # encontra os coeficientes (realiza a regressão)

#realiza a previsão
previsao=reg.predict(x)

R_2 = r2_score(y, previsao)#realiza o cálculo do R2

print("Coeficiente de Determinação (R2):", R_2)

"""**Plotar um gráfico para 2 variáveis "lineares" para posteiriormente utilizar PCA**"""

sns.lmplot(x="GarageYrBlt", y="YearBuilt", data=dataframe)

sns.lmplot(x="GrLivArea", y="TotRmsAbvGrd", data=dataframe)

"""***Selecionar 2 atributos para transformar em um componente principal e aplicar PCA ***"""

pca = PCA(n_components=1)

pca.fit(dataframe[['GrLivArea', 'TotRmsAbvGrd']])

GrLivArea_TotRmsAbvGrd = pca.transform(dataframe[['GrLivArea', 'TotRmsAbvGrd']])

dataframe['GrLivArea_TotRmsAbvGrd'] = GrLivArea_TotRmsAbvGrd

dataframe.drop(['GrLivArea', 'TotRmsAbvGrd'], axis=1,inplace=True)

"""***Aplicar ao modelo de regressão (dado pelo professor) e verificar a acurácia***"""

#Realiza a construção do modelo de regressão
reg= LinearRegression()
#x_Reshaped=x.reshape((-1, 1)) #coloca os dados no formato 2D
regressao= reg.fit(x,y) # encontra os coeficientes (realiza a regressão)

#realiza a previsão
previsao=reg.predict(x)

#parâmetros encontrados
print('Y = {}X {}'.format(reg.coef_,reg.intercept_))

R_2 = r2_score(y, previsao)  #realiza o cálculo do R2

print("Coeficiente de Determinação (R2):", R_2)