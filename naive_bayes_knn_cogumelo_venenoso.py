# -*- coding: utf-8 -*-
"""naive_bayes_knn_cogumelo_venenoso.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vxRLGaLduNW2j9yqp5KqtNTrUDf7qK1Z

Este conjunto de dados inclui descrições de amostras hipotéticas correspondentes a 23 espécies de cogumelos guelados na família de cogumelos Agaricus e Lepiota, extraídas do Guia de campo da Audubon Society to North American Mushrooms (1981). Cada espécie é identificada como definitivamente comestível, definitivamente venenosa ou de comestibilidade desconhecida e não recomendada. Esta última classe foi combinada com a venenosa. O Guia afirma claramente que não existe uma regra simples para determinar a comestibilidade de um cogumelo; nenhuma regra como "folhetos três, deixe estar" para Carvalho Venenoso e Ivy

Informações de atributos: 

ALVO : (classes: comestíveis = e, venenosos = p)

forma de capa: sino = b, cônico = c, convexo = x, plano = f, saliente = k, afundado = s

superfície da capa: fibrosa = f, sulcos = g, escamosa = y, lisa = s

cor da tampa: marrom = n, amarelo-claro = b, canela = c, cinza = g, verde = r, rosa = p, roxo = u, vermelho = e, branco = w, amarelo = y

hematomas: hematomas = t, não = f

odor: amêndoa = a, anis = l, creosoto = c, peixe = y, fétido = f, mofo = m, nenhum = n, pungente = p, picante = s

anexo de brânquia: anexado = a, descendente = d, livre = f, entalhado = n

espaçamento de guelras: próximo = c, lotado = w, distante = d

tamanho da guelra: largo = b, estreito = n

cor de guelras: preto = k, marrom = n, amarelo-claro = b, chocolate = h, cinza = g, verde = r, laranja = o, rosa = p, roxo = u, vermelho = e, branco = w, amarelo = y

forma de haste: ampliação = e, afilamento = t

raiz do caule: bulboso = b, clube = c, xícara = u, igual = e, rizomorfos = z, enraizado = r, ausente =?

superfície da haste acima do anel: fibroso = f, escamoso = y, sedoso = k, liso = s

superfície do caule abaixo do anel: fibroso = f, escamoso = y, sedoso = k, liso = s

talo-cor-acima do anel: marrom = n, amarelo = b, canela = c, cinza = g, laranja = o, rosa = p, vermelho = e, branco = w, amarelo = y

stalk-color-below-ring: brown = n, buff = b, cannamon = c, grey = g, orange = o, pink = p, red = e, white = w, yellow = y

tipo de véu: parcial = p, universal = u

cor do véu: marrom = n, laranja = o, branco = w, amarelo = y

número do anel: nenhum = n, um = o, dois = t

tipo de anel: teia de aranha = c, evanescente = e, alargamento = f, grande = l, nenhum = n, pendente = p, revestimento = s, zona = z

spore-print-color: black = k, brown = n, buff = b, chocolate = h, green = r, orange = o, purple = u, white = w, yellow = y

população: abundante = a, agrupado = c, numeroso = n, espalhado = s, vários = v, solitário = y

habitat: gramíneas = g, folhas = l, prados = m, caminhos = p, urbano = u, resíduos = w, bosques = d

..........................................................................

**Objetivo:** É seu trabalho como engenheiro da computação prever se o cogumelo é venenoso ou comestível, ou seja, criar um modelo para isso.

**Itens que você deve cumprir**:

*   Mostrar informações do data_set (head,info,describe)
*   Verificar dados faltantes, se houver, fazer tratamento. 
*   Detectar atributos categóricos.
*   Utilizar Ordinal Encoding ou One hot encoding para transformar os atributos em “números”, você escolhe a técnica.
*   Separar os dados em x_train,x_test,y_train,y_test 
*   Aplicar o técnica de Naive Bayes e verificar o score (accuracy_score)
*   Aplicar o técnica de KNN e verificar o score (accuracy_score)
*   Variar K do modelo KNN entre (1 e 100) e apresentar um gráfico da evolução de K e o accuracy_score (você pode utilizar o erro ((np.mean(pred_i != y_test))para substituir o accuracy_score)
"""

import pandas as pd #biblioteca utilizada para o tratamento de dados via dataframes 
import numpy as np #biblioteca utilizada para o tratamento de valores numéricos (vetores e matrizes)
import matplotlib.pyplot as plt #biblioteca utilizada para construir os gráficos
import seaborn as sns #biblioteca utilizada para construir os gráficos
from sklearn.feature_selection import RFE #biblioteca para aplicação RFE
from sklearn.metrics import r2_score #método para o cálculo do R2 (coeficiente de determinação)
from sklearn.model_selection import train_test_split 
from sklearn.neighbors import KNeighborsClassifier 
from sklearn.metrics import  accuracy_score # Importando métricas para validação do modelo
from sklearn.naive_bayes import GaussianNB

from google.colab import files  #biblioteca utilizada para carregar os dados para o google colab
uploaded = files.upload()

"""**Apresentar informações do data_frame (head, info, describe)**"""

nome_do_arquivo="mushrooms.csv" 
dataframe = pd.read_csv(nome_do_arquivo)

dataframe.head()

dataframe.info()

dataframe.describe()

"""**Varificar os dados nulos, e fazer possíveis tratamentos**"""

dataframe.isnull().sum()

"""
**Detectar atributos categóricos. Utilizar Ordinal Encoding ou One hot encoding para transformar os atributos em “números”, você escolhe a técnica.**
"""

from sklearn.preprocessing import OrdinalEncoder

enc = OrdinalEncoder()

x = dataframe[['bruises','odor','gill-size','gill-color','veil-type','spore-print-color','ring-number','ring-type','habitat']]

enc.fit(x)

enc.categories_

x_transformed = enc.transform(x)

y = dataframe[['class']]

enc2 = OrdinalEncoder()

enc2.fit(y)

enc2.categories_

y_transformed = enc2.transform(y)

"""**Separar os dados em x_train,x_test,y_train,y_test**"""

from sklearn.model_selection import train_test_split

x2 = x_transformed

y2 = y_transformed

x_train, x_test, y_train, y_test = train_test_split(x2, y2, test_size=0.33, random_state=42)

"""** **Aplicar o técnica de Naive Bayes** **"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
cols = ["dado", "valor"]
dados = pd.DataFrame(np.array(["x1",7],["x2",12],["x3",2],["x4",21],["x5",66]),columns=cols)
scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(dados)

dados = [30,20,15,155,2]

padronizado = scale(dados)

padronizado

from sklearn.naive_bayes import GaussianNB

model_NB = GaussianNB()

model_NB.fit(x_train,y_train)

pred_NB = model_NB.predict(x_test)

"""**Verificar o score (accuracy_score)**"""

from sklearn.metrics import accuracy_score

accuracy_score(y_test,pred_NB)

"""**Aplicar o técnica de KNN **"""

from sklearn.neighbors import KNeighborsClassifier

model_KNN = KNeighborsClassifier(n_neighbors=13)

model_KNN.fit(x_train,y_train)

pred_KNN = model_KNN.predict(x_test)

"""**Verificar o score (accuracy_score)**"""

accuracy_score(y_test,pred_KNN)

"""**Variar K do modelo KNN entre (1 e 100) e apresentar um gráfico da evolução de K e o accuracy_score (você pode utilizar o erro ((np.mean(pred_i != y_test))para substituir o accuracy_score)**"""

K_n = 100
k_list = []
acc_list = []

for x in range(1, K_n):
  model_KNN = KNeighborsClassifier(n_neighbors=x)
  model_KNN.fit(x_train,y_train)
  pred_KNN = model_KNN.predict(x_test)
  acc = accuracy_score(y_test,pred_KNN)
  k_list.append(x)
  acc_list.append(acc)

sns.lineplot(x=k_list, y=acc_list)